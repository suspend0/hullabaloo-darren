<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Darren Gilroy: Code Review Guidelines</title>
<link rel="stylesheet" type="text/css" href="style.css">
<link rel="stylesheet" type="text/css" href="code-review.css">
<script type="text/javascript" src="jquery-20070210.js"></script>
<script type="text/javascript" src="init.js"></script>
</head>
<body>
<noscript>
  <div class="errmsg">
    I use some javascript on this site.  Not a lot, but some.
  </div>
</noscript>

<div id="header"></div>

<div class="content">

<div class="aux">
  <p>The tone of this is a bit <b>severe</b> sometimes, but I
    take this silly stuff seriously sometimes.</p> 
  <p>I wrote <b>most</b> of this, but I make no promises that I didn't 
    crib large portions from some random website or posting.</p>
  <p>I've been thinking about this stuff for a while and just
    took an afternoon to write it all down. I made this for work;
    those in the know will recognize it.</p>
</div>

<div class="main">

<h1>Code Review Guidelines</h1>
<p>Code is evaluated on the basis of two principles:</p>
<ol>
  <li>Does it do what it is supposed to do?</li>
  <li>Will I understand the code when I go back to it in 6
months?</li>
</ol>
<p>We want effective, readable code.</p>

<h2>Introduction</h2>
<p>There are as many programming styles as there are
programmers, and nearly any randomly selected style is adequate -- although
some standards are arguably much worse than the norm.  The primary benefit of a
programming style for an individual programmer is that it's easier to
understand your own work.  The same motivation drives programming teams: if the
team has a common style then it's easier for the team to understand the 
work.</p>

<p>Invariably this requires some compromise, as each programmer
gives up a little bit of their (essentially arbitrary) style choices in
preference for common ones, and gets back in return the ability to read other
team members' code.</p>

<p>The standard below derives its advantage from its use.  Use
it.</p>

<h2>The Review Process</h2>
<p>This is a high-level outline of the process</p>

<h3>Before We Begin</h3>
<ol>
  <li>The code must compile</li>
  <li>The code must work as expected</li>
  <li>Test cases must be written and the code must pass them</li>
</ol>

<h3>Reviewing</h3>
<ol>
  <li>Review the code</li>
  <li>Ask questions</li>
  <li>Note things that don't conform to the standard</li>
  <li>Suggest alternate implementations</li>
</ol>

<h3>After We Are Done</h3>
<ol>
  <li>Modify the code to make it better</li>
  <li>Repeat, if necessary</li>
</ol>

<h2>Guidelines Overview</h2>
<ul>
  <li><a href="#comments">Check for Comments in the Code</a></li>
  <li><a href="#logging">Check for Logging</a></li>
  <li><a href="#error-handling">Check for Error Handling</a></li>
  <li><a href="#readable-handling">Check for Readable Error Handling</a></li>
  <li><a href="#resource">Check for Resource Closing</a></li>
  <li><a href="#var-decl">Check Variable Declarations</a></li>
  <li><a href="#var-names">Check Variable Names</a></li>
  <li><a href="#class-org">Check Class Organization</a></li>
  <li><a href="#debug-friendly">Check for Debugger-Friendly Code</a></li>
  <li><a href="#utility">Check for Utility Methods and Utility Classes</a></li>
  <li><a href="#performance">Check for Performance Gotcha</a></li>
  <li><a href="#api-respect">Check for API Respect</a></li>
  <li><a href="#constructors">Check for Superfluous Constructors</a></li>
  <li><a href="#thread-safety">Check for Thread Safety</a></li>
  <li><a href="#unusual-cond">Check for Treatment of Unusual Conditions</a></li>
  <li><a href="#null-ref">Check that References are made Null</a></li>
  <li><a href="#stupid-classes">Check for a Bunch of Stupid Classes</a></li>
  <li><a href="#class-name">Check Class and Interface Naming</a></li>
  <li><a href="#package-name">Check Package Naming</a></li>
  <li><a href="#flow-control">Check Flow Control &amp; Readability</a></li>
  <li><a href="#flow-complex">Check Flow Control &amp; Complexity</a></li>
  <li><a href="#cleanliness">Check General Cleanliness</a></li>
  <li><a href="#test-cases">Check for Test Cases</a></li>
</ul>

<h2>The Review Guidelines</h2>
<p>We will be using this standard during code review.  Code
that does not meet these standards will need to be modified before you forget
what the code is supposed to be doing. These are in no particular order of
importance.</p>

<h3>Check for Comments in the Code<a name="comments"></a></h3>
<ul type="disc">
<li>This means JavaDoc certainly.  Javadoc comments should
have meaning.  Decorating a bunch of getters with "returns the
Subscription ID, returns the Name, returns the Production Id" are not
useful.</li>
<li>Explanatory comments about what we are doing and why we
are doing it.</li>
<li>Anything that is not implemented must be marked with the
Eclipse TODO comment.</li>

<li>Complex methods/algorithms must have inline comments
explaining what's going on.</li>
<li>Notes explaining implementation choices or things
considered-but-rejected are encouraged.</li>
<li>Comment your <b>variables</b> as well as your methods.</li>
<li>Verify that comments identify units of measurement. If a
variable or parameter represents time, indicate if it's seconds or
milliseconds.</li>
<li>Commented-out code should have an explanation as to why
it's commented. If it's dead code it should be removed, if it's a
temporary hack, identify it as such.</li>
</ul>

<h3>Check for Logging<a name="logging"></a></h3>
<ul type="disc">
<li>Log interesting events.  Think carefully about the log
level you use.  Petar likes lots of information in his logs and has been
known to leave Level.INFO on for production servers.</li>
<li>We use java.util.logging for our projects, which has the
following Log levels:
<ul type="circle">
<li>SEVERE (highest value) &#8211; We have some error that cannot
be handled and we should throw it but we cannot (such as inside a run()
method)</li>
<li>WARNING &#8211; We have something we know is bad, but we thing
we can retry or otherwise compensate</li>
<li>INFO &#8211; something interesting is happening</li>
<li>CONFIG &#8211; I am logging the configuration values I am
reading, the implementations chosen for pluggable interfaces, etc.</li>
<li>FINE &#8211; something of interest to the programmer when stuff
is going fine </li>
<li>FINER &#8211; something of interest to the programmer when
debugging</li>
<li>FINEST (lowest value) &#8211; something of interesting to the
programmer when we just need to see absolutely everything.</li>
</ul>
</li>
<li>Log messages <i>must</i> include the pertinent data.  If
you have trouble reading a URL, include the URL, if you have trouble
opening or closing a file, include the file name, etc, if you get a
transformation exception include the document you are using as input.</li>
<li>Log when you are waiting on something that may take some
amount of time.  If you expect significant time, consider a background
thread with a "still waiting" message.</li>
</ul>

<h3>Check for Error Handling<a name="error-handling"></a></h3>
<p>Error handling is an essential part of any program and in
Java especially is considered part of the method API.</p>
<ul type="disc">
<li>If an error occurs, handle it or throw the exception. 
Each method call is a contract, if it completes, the caller has expected
you to perform what it asked you to.  No hiding error messages.  
No <code>catch() { return null; }</code> unless this is part of the API.</li>
<li>When you throw a new exception based on another exception,
include some additional information.  For example, if you can't parse a
string to an <code>int</code>,
include the string you were trying to parse.</li>
<li>Make sure you validate your input.  Check for null
reference,</li>
</ul>
<h3>Check for Readable Error Handling<a name="readable-handling"></a></h3>
<p>Try blocks can sometimes interfere with the readability of
code.   Find ways to minimize their impact.</p>
<ul type="disc">
<li>Keep try blocks as large as you can.</li>
</ul>

<pre>
try {
   do something
} catch(SomeException e) {
   throw new OtherException(e);
}
do some other thing
try {
  do a third thing
} catch(MoreException e) {
  throw some OtherException(e);
}
and continue to do stuff.
</pre>
<p> </p>
<p>It's better to consolidate our try blocks so the flow of code
is easier to understand, for example</p>

<pre>
try {
   do something
   do some other thing
   do a third thing
   and continue to do stuff
} catch(SomeException e) {
   throw new OtherException(e);
} catch(MoreException e) {
  throw some OtherException(e);
}
</pre>

<ul type="disc">
<li>Factor out repetitive try blocks.</li>
</ul>
<pre>
if( var1 != null ) {
   try {
     int value = Integer.parse(var1) {
   } catch (NumberFormatException e) {
     throw new SomeOtherException(
        "could not parse to integer:"+var1, e);
   }
}
else if( var2 != null ) {
   try {
     int value = Integer.parse(var1) {
   } catch (NumberFormatException e) {
     throw new SomeOtherException(
        "could not parse to integer":+var2, e);
   }
}
</pre>
<p>Instead, try this</p>
<pre>
if( var1 != null ) {
   int value = parseInt(var1);
}

else if( var2 != null ) {
   int value = parseInt(var2);
}

private int parseInt(String var) 
  throws SomeOtherException {
   try {
     int value = Integer.parse(var) {
   } catch (NumberFormatException e) {
     throw new SomeOtherException(
        "could not parse to integer:"+var, e);
   }
}
</pre>

<h3>Check for Resource Closing<a name="resource"></a></h3>
<p>Make sure any external resources are closed.  Check:</p>
<ul type="disc">
  <li>DB &amp; Network connections</li>
  <li>files &amp; streams</li>
  <li>prepared statements &amp; result sets</li>
  <li>Pooled objects returned to the pool</li>
</ul>
<p>Check this happens in error-paths too.</p>

<h3>Check Variable Declarations<a name="var-decl"></a></h3>
<ul type="disc">
  <li>Use final as often as you can.  Final double-checks that a
    value is assigned during construction, and accesses to final references do
    not need to be synchronized by the JVM so they are a bit faster. 
    (Synchronized to the reference itself, not the underlying object)</li>
  <li>Check that static variables are referenced in a static way.</li>
  <li>Use transient when appropriate</li>
  <li>Use volatile when appropriate (accessing volatile
    variables is slower than non-volatile variables but not as slow as
    synchronization)</li>
</ul>

<h3>Check Variable Names<a name="var-names"></a></h3>
<p>This is contentious, second perhaps only to brace
formatting, but here we go:</p>

<ul type="disc">
<li>Preface instance variables with "this".  Do not use
m_varName or _varName or any other syntax</li>
<li>You may use s_ for static (class) variables, but this is
not required.</li>
<li>Do not use 'tmp' or '_' or any other syntax for temporary
variables.  Use something with a bit of meaning, for example</li>
</ul>
<pre>
SConnection sconn = SConnection.getConnection();
Connection jdbcconn = sconn.getJDBCConnection();
do something with jdbcconn
</pre>

<p>Is Preferred to </p>

<pre>
SConnection _conn = SConnection.getConnection();
Connection conn = sconn.getJDBCConnection();
do something with conn
</pre>

<h3>Check Inner Classes</h3>
<p>Some general notes about class structure</p>
<ul type="disc">
<li>Inner classes: OK</li>
<li>Multiple classes per file: Not OK</li>
<li>Static Inner Classes: Encouraged </li>
</ul>
<p>However, some restrictions on inner classes</p>
<ul type="disc">
<li>Don't reference your inner class from another class</li>
</ul>

<p>Keep in mind that Enum types are inner classes too!  Declare
them static unless this is impossible; make them their own class if you need to
reference them from other places. (There can be exceptions here)</p>
<h3>Check Class Organization<a name="class-org"></a></h3>
<p>Organize your classes in the following order:</p>
<ol>
<li>The first line should be the logger variable </li>
<li>Any static variable and static{} initializer blocks</li>
<li>Any instance variables</li>
<li>Constructors (least number of parameters to most number of
parameters)</li>

<li>Public Methods</li>
<li>Protected Methods</li>
<li>Private Methods</li>
<li>Inner classes</li>
</ol>

<p>Static variables, instance variables, and methods should be
sorted alphabetically within their types, unless there is a logical grouping
that makes more sense.</p>

<p>If it makes sense to order your class in a different way &#8211;
for example by function or implanted interface, you must use large comments to
indicate the separate areas. For example:</p>

<pre>
// --- javax.jms.Message methods ----
methods to implement Message

// --- RequiresResponseMessage methods ----
methods to implement the interface 
RequiresResponseMessage
</pre>

<h3>Check for Debugger-Friendly Code<a name="debug-friendly"></a></h3>
<p>Take care to code with debugging in mind.  This is just
simple things like:</p>

<pre>
private static String doSomeWork(String param1, 
  String param2) 
{
   String r = abc(param1) + bbc(param2);
   return r;
}
</pre>

<p>Is preferred to </p>

<pre>
private static String doSomeWork(String
  param1, String param2) 
{
   return abc(param1) + bbc(param2);
}
</pre>

<p>simply because the value of "r" can be seen by the debugger
before returning.  Methods abc() and bbc() should follow the same pattern.</p>
<h3>Check for Utility Methods and Utility Classes<a name="utility"></a></h3>

<ul type="disc">
<li>There are common classes for database access
(SConnection), Http access (HttpClient), file access
Environment.getInputStream().  Check your code uses these common methods. </li>

<li>Utility classes exist for a lot of common tasks.  Don't
reinvent the wheel.</li>
</ul>
<h3>Check for Performance Gotcha<a name="performance"></a></h3>
<ul type="disc">
<li>Keep performance considerations at the forefront &#8211; don't
do loops if they are not required, don't copy data that doesn't need to be
copied, don't create a bunch of objects when a pool is reasonable, buffer
your input and output streams, etc.</li>
<li>Check for infinite loops or un-ending recursion.  Verify
that recursive functions use a reasonable amount of stack space.</li>
<li>Check for spin loops (busy waits).  Normally you are
better off with some other kind of, synchronization method.</li>
</ul>

<p>However, performance should never (well, rarely) come at the
expense of readability.  <i>Some optimizations just aren't needed.</i></p>

<h3>Check for API Respect<a name="api-respect"></a></h3>
<p>This can be a difficult thing to do, because your
implementation may or may not have any of the constraints that are specified by
the API.  If the API specifies that implementations need not be thread safe, or
reusable or whatever, you should respect that in your use of your 
implementations of the API.</p>

<p>There are exceptions; here is an example of a good exception</p>

<pre>
// readers are reusable
XMLReader reader = XMLReaderFactory.newInstance();

// content handlers are not but my object is
ContentHandler ch = new MyReusableContentHandler();

for( String url : listOfUrls ) {
   // This is OK since I know the
implementation
   reader.setContentHandler(ch);
   reader.parse();
}
</pre>

<p>And here is an example when you <b>don't</b> want to reuse a
handler</p>

<pre>
class MyClass {
   private ContentHandler ch;
 
   public void setContentHandler(ContentHandler ch) {
     this.ch = ch;
   }
 
   public void run() {
     // readers are reusable
     XMLReader reader = XMLReaderFactory.newInstance();
 
     for( String url : listOfUrls ) {
        // you shouldn't resuse this
        // content handler since you 

        // don't know the implementation.
        reader.setContentHandler(ch);
        reader.parse();
     }
   }
}
</pre>

<h3>Check for Superfluous Constructors<a name="constructors"></a></h3>

<p>Avoid private constructors.  </p>
<ul type="disc">
  <li>If you have a class that has just static methods and should
not be instantiated, there is no reason why you can't leave a public
no-argument constructor.  This will allow the class to be manipulated by
tools a little easier.  If somebody constructs an instance: no big deal. 
Leave a javadoc with something like "this class should not be constructed
during standard programming" (like they do at Jakarta.)</li>
  <li>If you have a class where you should use a factory to
create it, then make the constructor protected so at some point you can
subclass it.</li>
</ul>

<p>Be judicious with convenience constructors</p>
<ul type="disc">
  <li>Unless you are building a library, you should keep
convenience constructors to a reasonable amount.  If you do have some, try
to use the <code>this()</code>
constructor as much as possible.</li>
</ul>

<h3>Check for Thread Safety<a name="thread-safety"></a></h3>

<ul type="disc">
<li>Classes that are thread-safe must be marked as such in the
class's JavaDoc.  If you extend a class or implement an interface that is
not thread safe, avoid trying to make your implementation thread-safe.</li>
<li>Check for deadlock conditions.  If object #1 and object #2
share two monitors A and B, they should both lock the monitors in the same
order</li>
<li>Don't over-use the synchronize statement.  Of course it's
important to synchronize some accesses, but with good class design you
shouldn't have to synchronize every method.  Often times that doesn't get
you thread safety anyway.</li>
<li>Check for race conditions. </li>
<li>Check that static variables are used in a thread-safe way
&#8211; even in classes that are not declared thread-safe.  For example this bug
from GoogleSearchServlet:</li>
</ul>

<pre>
private static volatile boolean
   s_usingBackup = false;

private void switch() {
  if(s_usingBackup) {
    s_url = primaryUrl;
    s_using_backup = false;
  }
  else {
    s_url = backupUrl;
    s_usingBackup = true;
  }
}
 
void doGet(HttpServletRequest request
    HttpServletResponse response) 
{
  try {
    doGoogle(s_url, response.getWriter());
  catch (Exception e) {
    switch();
  }
}
</pre>

<p>The problem is that doGoogle() is quite long, and the value
of s_usingBackup may have been changed by another thread.  A simple "fix" is to
have two methods switchToBackup() and switchToPrimary() that use the value of
s_usingBackup to decide if a switch actually needs to occur.</p>
<h3>Check for Treatment of Unusual Conditions<a name="unusual-cond"></a></h3>
<p>It's important to recognize in your code that the world is
not a perfect place.  Exceptions get thrown, threads die, and things get out of
sync.  Assume that it happens and compensate.  </p>
<p> </p>
<p>For example, if you have a SAX ContentHandler (that you've
declared reusable) which increments a level variable for each startElement()
and decrements for each endElement().  At the end of the parse this level
variable will be 0.  However, you should <i>still set the level variable to
zero in startDocument()</i> so that if something causes an exception to be
thrown your code continues to work correctly on the next run.  Setting the
level to zero is endDocument() will have little effect.</p>

<h3>Check that References are made Null<a name="null-ref"></a></h3>
<p>If you have an object who's working pattern is :</p>
<pre>
myobj.setThis(whatever);
myobj.setThat(else);
myobj.setThe(we);
myobj.setOther(have);
myobj.doSomeWork():
</pre>

<p>Then you should null the references you store to 
  <code>This, That, The,</code>
  and
  <code>Other</code>.  When you
do this depends on your needs.  If you are pooling MyObj then you could
implement a recycle() method.  </p>

<p>Watch for instances when your lifecycle is different than
the objects you are referencing.  This is especially important for <code>ThreadLocal</code>s.</p>

<h3>Check for a Bunch of Stupid Classes<a name="stupid-classes"></a></h3>

<p>Avoid classes that don't do anything.  If you have a class
with one static method, and expectation of growth, it can probably find a home
somewhere else.  Also, static methods and static classes are often an indicator
of functional (rather than object-oriented) programming &#8211; be judicious.</p>
<h3>Check Class and Interface Naming<a name="class-name"></a></h3>
<p>This is another difficult one, but here goes:</p>
<ul type="disc">
<li>Use nouns</li>
<li>For static classes use "XXXUtils" not "XXXUtil".  Don't go
crazy with this.</li>
<li>Don't tag interfaces with "ISomething" or "SomethingInf". 
Just "Something"</li>
<li>Don't tag a concrete class with "SomethingImpl" &#8211; use a
descriptive name like "SingleThreadedSomething" or "JabberwockySomething",
or at the very worst "DefaultSomething"</li>
<li>For abstract classes that you intend to use this as a base
class should be called "AbstractSomething". If you have something that is
more like "an interface with implementations", just use "Something", if
you have an abstract class that's meant to hide implementations, use
"SomethingFactory".  (Note the difference in use and naming between
abstract classes AbstractCollection and TransformerFactory)</li>

<li>Don't call anything FBFSomething.  The whole project if
FBF &#8211; is we have an FBFConnection then we probably have some reason we
can't just use Connection &#8211; put this in your class name.</li>
</ul>
<h3>Check Package Naming<a name="package-name"></a></h3>
<ul type="disc">
<li>No deeply nested hierarchies!!!!!!!!!!!</li>
<li>Don't have any packages with just a class or two.  Be
judicious.</li>
<li>Don't have any packages called 'fbf'</li>
<li>Don't create packages for different implementations.  For
example, follow the style of org.xml.sax.helpers in preference to
javax.xml.transform.stream / javax.xml.transform.dom / javax.xml.transform.sax</li>
<li>Don't have packages named with the technology, name for
the purpose.   A package name "xmlfilters" is discouraged, while a package
named "handlers" is a better.</li>
</ul>

<p>There are exceptions, for example
com.fujtisu.fbf.fbf3.assembler.velocity is fine.</p>
<h3>Check Flow Control &amp; Readability<a name="flow-control"></a></h3>
<p>When using if statements, put the most likely first, or the
exception first, depending on what you are trying to do.  Examples</p>

<pre>
// Good 
if(x == null) {
   throw new Exception("x is null");
}
do some 30 lines of work here with X
</pre>
<pre>
// OK, but too much indenting<
if(x == null) {
   throw new Exception("x is null");
} 
else {
   do some 30 lines of work here with X
}
</pre>

<pre>
// BAD &#8211; this hides the reason for the 'if'
30 lines below
if(x != null) 
   do some 30 lines of work here with X
}
else {
   throw new Exception("x is null");
}
</pre>

<h3>Check Flow Control &amp; Complexity<a name="flow-complex"></a></h3>
<p>One of the measures of the complexity of a method is the
number of decision points in it.  Keep your conditionals within your methods
down!</p>
<p> </p>
<p>A common method if calculating code complexity is
"Cyclomatic Complexity", which is just the number of decision points (if, else
if, for, while, switch, etc) plus one.</p>
<p> </p>

<ul type="disc">
<li>1-10: a simple program, without much risk </li>
<li>11-20 more complex, moderate risk </li>
<li>21-50 complex, high risk </li>
<li>51+ untestable, very high risk</li>
</ul>
<p> </p>
<p>Source: <a href="http://www.linuxjournal.com/article/8035" target="_blank" onclick="return top.js.OpenExtLink(window,event,this)">http://www.linuxjournal.com/article/8035</a></p>
<h3>Check General Cleanliness<a name="cleanliness"></a></h3>

<ul type="disc">
<li>Don't leave eclipse-generated TODO unless you actually
intend to do.</li>
<li>Don't leave the default "non-javadoc" messages</li>
<li>Don't leave the eclipse-generated arg0, arg1 method
parameters.  Rename them by hand or attach source so Eclipse can figure it
out.</li>
<li>Format your code with the formatter before you check it
in.</li>
<li>Remove unused imports</li>
<li>Make sure it compiles.  </li>
</ul>
<h3>Check for Test Cases<a name="test-cases"></a></h3>
<p>Test cases should be written for each part of the code. 
Test cases should be of reasonable granularity.</p>

</div><!--/main-->

</div><!--/content-->

<div class="footer" id="footer"></div>
</body>
</html>
