package ca.hullabaloo.guice;

import com.google.common.collect.AbstractIterator;
import com.google.common.collect.Lists;
import com.google.inject.Binder;
import com.google.inject.Binding;
import com.google.inject.Key;
import com.google.inject.Module;
import com.google.inject.binder.AnnotatedBindingBuilder;
import com.google.inject.binder.LinkedBindingBuilder;
import com.google.inject.privatemodules.PrivateModule;
import com.google.inject.spi.DefaultElementVisitor;
import com.google.inject.spi.Element;
import com.google.inject.spi.Elements;
import com.google.inject.spi.ModuleWriter;
import java.lang.annotation.Annotation;
import java.util.List;
import java.util.ListIterator;

/**
 * Provides enhanced EDSL syntax for PrivateModules.  Doesn't provide the full power of
 * private modules, but it's appropriate for simple cases.
 *
 * Uses PrivateModules internally.
 *
 * Private Modules:
 * <pre>
 * class RobotLegsModule extends AbstractModule {
 *   @Override protected void configure() {
 *     install(new PrivateModule() {
 *       @Override protected void configurePrivateBindings() {
 *         bind(Source.class).to(MyNumbers.class);
 *         bind(View.class).annotatedWith(Names.named("mine")).to(EvenView.class);
 *         expose(View.class).annotatedWith(Names.named("mine"));
 *       }
 *     });
 *     install(new PrivateModule() {
 *       @Override protected void configurePrivateBindings() {
 *         bind(Source.class).to(YourNumbers.class);
 *         bind(View.class).annotatedWith(Names.named("yours")).to(OddView.class);
 *         expose(View.class).annotatedWith(Names.named("yours"));
 *       }
 *     });
 *   ...
 * }
 * </pre>
 * With EDSL
 * <pre>
 * class RobotLegsModule extends XAbstractModule {
 *   bind(View.class).annotatedWith(Names.named("mine")).to(EvenView.class)
 *      .with(Source.class).to(MyNumbers.class)
 *   bind(View.class).annotatedWith(Names.named("yours")).to(OddView.class)
 *      .with(Source.class).to(YourNumbers.class)
 *   ...
 * }
 * </pre>
 */
public abstract class XAbstractModule implements Module {
  // ======================================
  // Implementations of BindingBuilders, can't extends regular AnnotatedBindingBuilder
  // because we need to overload the void returned from the methods of ScopedBindingBuilder

  public interface WithScopedBindingBuilder {
    <T> WithAnnotatedBindingBuilder<T> with(Class<T> sourceClass);
  }

  public interface WithLinkedBindingBuilder<T> extends WithScopedBindingBuilder {
    WithScopedBindingBuilder to(Class<? extends T> impl);
  }

  public interface WithAnnotatedBindingBuilder<T> extends WithLinkedBindingBuilder<T> {
    WithLinkedBindingBuilder<T> annotatedWith(Annotation annotation);
  }

  private enum ElementType {
    BINDING, MARKER, OTHER
  }

  private static class KeyVisitor extends DefaultElementVisitor<Key> {
    public <T> Key<T> visitBinding(Binding<T> binding) {
      return binding.getKey();
    }

    protected Key visitElement(Element element) {
      throw new IllegalArgumentException();
    }
  }

  private static class PrivateElementIter extends AbstractIterator<Element> {
    private final ListIterator<Element> baseIter;
    private boolean returnOne = true;

    public PrivateElementIter(ListIterator<Element> baseIter) {
      this.baseIter = baseIter;
    }

    protected Element computeNext() {
      while (this.baseIter.hasNext()) {
        Element item = baseIter.next();
        if (returnOne) {
          returnOne = false;
          return item;
        }
        if (isMarker(item)) {
          returnOne = true;
          continue;
        }
        baseIter.previous(); // return the item
        break;
      }
      return endOfData();
    }
  }

  private static class PublicElementIter extends AbstractIterator<Element> {
    private final ListIterator<Element> baseIter;

    public PublicElementIter(ListIterator<Element> baseIter) {
      this.baseIter = baseIter;
    }

    protected Element computeNext() {
      if (!baseIter.hasNext()) {
        return endOfData();
      }

      Element item = baseIter.next();
      if (nextIsMarker(baseIter)) {
        baseIter.previous(); // put item back
        return endOfData();
      }
      return item;
    }
  }

  private static class TypeVisitor extends DefaultElementVisitor<ElementType> {
    public <T> ElementType visitBinding(Binding<T> binding) {
      if (binding.getKey().getTypeLiteral().getType() == WithMarker.class) {
        return ElementType.MARKER;
      }
      return ElementType.BINDING;
    }

    protected ElementType visitElement(Element element) {
      return ElementType.OTHER;
    }
  }

  private class WithBuilder<T> implements WithAnnotatedBindingBuilder<T> {
    private AnnotatedBindingBuilder<T> abb;
    private LinkedBindingBuilder<T> lbb;

    public WithBuilder(AnnotatedBindingBuilder<T> bindingBuilder) {
      this.lbb = this.abb = bindingBuilder;
    }

    public WithLinkedBindingBuilder<T> annotatedWith(Annotation annotation) {
      this.lbb = this.abb.annotatedWith(annotation);
      this.abb = null;
      return this;
    }

    public WithScopedBindingBuilder to(Class<? extends T> impl) {
      this.lbb.to(impl);
      this.lbb = null;
      return this;
    }

    public <T> WithAnnotatedBindingBuilder<T> with(Class<T> sourceClass) {
      bind(WithMarker.class);
      return new WithBuilder<T>(privateBinder.bind(sourceClass));
    }
  }

  private static final class WithMarker {
  }

  // ====================================================
  private static boolean isMarker(Element element) {
    return element.acceptVisitor(new TypeVisitor()) == ElementType.MARKER;
  }

  @SuppressWarnings({ "unchecked" }) private static Key<Object> keyOf(Element element) {
    return element.acceptVisitor(new KeyVisitor());
  }

  private static boolean nextIsMarker(ListIterator<Element> baseIter) {
    if (!baseIter.hasNext()) {
      return false;
    }
    boolean result = isMarker(baseIter.next());
    baseIter.previous();
    return result;
  }

  private static boolean debug = false;

  private static void print(List<Element> el, String label) {
    if (debug) {

      System.out.println("--{" + el.size() + "} " + label);
      for (Element e : el) {
        System.out.println("--" + e);
      }
      System.out.println("-------------");
    }
  }

  // ====================================================
  private Binder publicBinder;
  private Binder privateBinder;

  public void configure(Binder binder) {
    if (this.publicBinder != null) {
      // reentrant from Elements.getElements();
      this.privateBinder = binder;
      configure();
      this.privateBinder = null;
    }
    else {
      this.publicBinder = binder;
      configureBindings();
    }
  }

  /**
   * Note this is the same bind(Class) that you get from AbstractModule, but it returns
   * a different binding builder type.
   */
  protected <T> WithAnnotatedBindingBuilder<T> bind(Class<T> type) {
    return new WithBuilder<T>(this.privateBinder.bind(type));
  }

  protected abstract void configure();

  /**
   * So, here's what's going on
   *
   *  1. Each time we call one of the new methods, we insert an extra binding to 'WithMarker'
   *  2. We get the list of bindings from Elements.getElements(this)
   *  3. We put the regular bindings in the public binder
   *  4. And create a PrivateModule for each set of private 'with' bindings
   *
   * EDSL like
   *   bind(X.class).to(Ex.class);
   *   bind(A.class).annotatedWith(Named.names("EN")).to(Eh.class)
   *     .with(B.class).to(Beer.class);
   *   bind(A.class).annotatedWith(Named.names("DE")).to(Eh.class)
   *     .with(B.class).to(Bier.class);
   *
   * An elements list like
   *   o Bind X to Ex
   *   o Bind A with @EN to Eh
   *   o Bind WithMarker
   *   o Bind B to Beer
   *   o Bind A with @DE to Eh
   *   o Bind WithMarker
   *   o Bind B to Bier
   *
   * And we transform this to
   *   o Bind X to Ex
   *   o Install PrivateModule
   *      o Bind A with @EN to Eh
   *      o Bind B to Beer
   *      o Expose A with @EN
   *   o Install PrivateModule
   *      o Bind A with @DE to Eh
   *      o Bind B to Bier
   *      o Expose A with @DE
   *
   * Much of the logic is in PublicElementIter and PrivateElementIter, each are responsible
   * for scanning forward from the current position and collecting as much of their type
   * as possible.  They don't return the Markers
   *
   * In the example above, it'd work like this
   *   1. start main iter loop over 7 items
   *   2. PublicElementIter() consumes 1, returns 1
   *   3. bind that one
   *   4. PrivateElementIter() consumes 3, returns 2
   *   5. install a module with those two
   *   6. loop again
   *   7. PublicElementIter() consumes 0, returns 0
   *   8. bind that one
   *   9. PrivateElementIter() consumes 3, returns 2
   *  10. install a module with those two
   *  11. loop exit
   */
  private void configureBindings() {
    List<Element> elements = Elements.getElements(this); // will re-enter at configure(Binder)
    print(elements, "all");
    ListIterator<Element> iter = elements.listIterator();

    // iterator 'iter' is advanced by PublicElementIter and PrivateElementIter
    while (iter.hasNext()) {
      // public bindings
      final List<Element> publicBindings = Lists.newArrayList(new PublicElementIter(iter));
      print(publicBindings, "public");
      if (!publicBindings.isEmpty()) {
        new ModuleWriter().apply(this.publicBinder, publicBindings);
      }

      // private bindings
      final List<Element> privateBindings = Lists.newArrayList(new PrivateElementIter(iter));
      print(privateBindings, "private");
      if (!privateBindings.isEmpty()) {
        this.publicBinder.install(new PrivateModule() {
          protected void configurePrivateBindings() {
            new ModuleWriter().apply(binder(), privateBindings);
            expose(keyOf(privateBindings.get(0)));
          }
        });
      }
    }
  }
}
